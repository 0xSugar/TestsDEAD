package com.company.learningRegex;

/**
 * Моя личная шпаргалка в начале изучения этих противных регулярок. Я даже не знаю, что противней, разбираться в
 * отличиях Массивов от Коллекций и Контейнеров (хотя массив тоже считается контейнером), понять смысл дофигища
 * методов в InputStream, OutputStream, Reader & Writer и в подолнение к этому работу именно буферизованных классов
 * или эти "регулярный выражения".
 */

/*
За регулярки отвечают 2 метода: Pattern, Matcher. Паттерну мы передаем <строку с выражением>, а второму - сам паттерн.
 1. Pattern это синглтон, т.е. создание объекта возможно только внутри самого класса. Что бы он создал и присвоил нам
объект - нужно объявить ссылку Pattern pattern и вызвать метод ('=') compile( куда передается строка ). К примеру:
String line = "A.+a";
Pattern patter = Pattern.compile(line, Pattern.CASE_INSENSITIVE);   // последний - сравнивает без учета регистра
В этом примере первое - строка с самим выражением, второе - режим сравнения шаблона с текстом.

Методы (пишутся pattern.METHOD();):
 - String .pattern()                    Возвращает строку с паттерном
 - boolean .matches(pattern, words)     Первое - паттерн (A.+a), второе - по чему сверять (строка, "Анна Егор Алекса")
 - int .flags()                         Вовзращает номер режима (шаблона)
 - String[] .split(words, 10)           Разбивает текст words на массив элеметров типа String. Вторым значением -
                                            определяет предельное кол-во совпадений, что нужно искать.
                                            больше 0 - столько и скать (к примеру если  3 - искать 3)
                                            меньше 0 - искать все
                                            равно 0 - искать все, пустые строки в конце массива отбрасываются

 2. Matcher - это "поисковик", движек. Что бы работать ему нужен шаблон по которому искать (паттерн) и где искать (строка).
За создание отвечает .matcher(), куда передаются строка, где искать (послед. символов), почти любые классы. Как работает:
Matcher matcher = patter.matcher(line);

Методы (matcher.find()):
 - boolean .find()                      Если находит - true, если нет - false
 - String .group()                      Дает строку того, что нашло
 - int .start()                         С какого индекса начинаются
 - int .end()                           На каком индексе заканчиваются
 - String .replaceFirst()               Заменить только первое совпадение на ("что-то еще");
 - String .replaceAll()                 Заменить все совпадения на ("что-то еще");

Пример:
String words = "Егор Алла Анна";
Pattern pattern = Pattern.compile("A.+?");

Matcher matcher = pattern.matcher(words);
while (matcher.find()) {
    int start = matcher.start();
    int end = matcher.end();
    System.out.printf("Совпадение: %s (начало с %d до %d)", words.substring(start, end), start, end-1");
}
System.out.println(matcher.replaceFirst("На-это"));     // Егор На-это Анна
System.out.println(matcher.replaceAll("На-это"));       // Егор На-это На-это
System.out.println(words);                              // Егор Алла Анна


Синтаксис - использования знаков <([{\^-=$!|]})?*+.> вместе с символами (буквами):
    1. Метасимволы для поиска совпадений границ строк или текста
        ^	начало строки
        $	конец строки
        \b	граница слова
        \B	не граница слова
        \A	начало ввода
        \G	конец предыдущего совпадения
        \Z	конец ввода
        \z	конец ввода
    2. Метасимволы для поиска символьных классов
        \d	цифровой символ
        \D	нецифровой символ
        \s	символ пробела
        \S	непробельный символ
        \w	буквенно-цифровой символ или знак подчёркивания [a-zA-Z0-9_]
        \W	любой символ, кроме буквенного, цифрового или знака подчёркивания
        .	любой символ
    3. Метасимволы для поиска символов редактирования текста
        \t	символ табуляции
        \n	символ новой строки
        \r	символ возврата каретки
        \f	переход на новую страницу
        \u0085	символ следующей строки
        \u2028	символ разделения строк
        \u2029	символ разделения абзацев
    4. Метасимволы для группировки символов
        [абв]	любой из перечисленных (а,б, или в)
        [^абв]	любой, кроме перечисленных (не а,б, в)
        [a-zA-Z]	слияние диапазонов (латинские символы от a до z без учета регистра )
        [a-d[m-p]]	объединение символов (от a до d и от m до p)
        [a-z&&[def]]	пересечение символов (символы d,e,f)
        [a-z&&[^bc]]	вычитание символов (символы a, d-z)
    5. Метасимволы для обозначения количества символов – квантификаторы. Квантификатор всегда следует после символа
    или группы символов.
        ?	один или отсутствует
        *	ноль или более раз
        +	один или более раз
        {n}	n раз
        {n,}	n раз и более
        {n,m}	не менее n раз и не более m раз
// Регулярные выражения задаются с использованем строкового литерала \, на который в Java есть своим правила. При
написании этого знака java ожидает какой-то спец-символ, он интрпритируется как символ управляющей последовательности.
Он предупреждает, что символ за ним - специальный и его нужно по другому итерпритировать. По этому тут это знак нужно
дублировать - \\ примеры (String l):
1. l = "\\s"                пробел
2. l = "\u2028"             Спец. знак
3. l = "How\\?"             How?
4. l = "\\"Welcome\\!\\""   "Welcome!" (?)
5. l = "\n"                 перево на новую строку
 */