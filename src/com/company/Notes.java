package com.company;

/**
 * @author skul
 */

public class Notes {
}
/*

Комбинации быстрые:
sout - System.out.println();
fori - for (int i = 0; i < ; i++);
Cmd + D = копирование строки;
Cmd + / ставит в начало строки //
Option + Shift передвигается строку выше или ниже
Option + Enter решает почти все проблемы
Control + N создать сеттеры, геттеры или что угодно

String
.toString();                вывести на экран
.indexOf("a");              получить индекс символа "а", выдаст первый с начала строки
.charAt("3");               получить букву под номером 2 (начинает считать с 0)
.toUpperCase();
.toLowerCase();
.toCharArray();             перевод в массив char... char [] = ...
.concat();                  объеденить..
.trim();                    удаляет начальные и конечные пробелы
.split("\\s");              разделяет строки там, где пробел (или можно указать другой знак). // String[] numbs = line.split(" "); (https://www.youtube.com/watch?v=j3I-jLGW8yU&list=PLAma_mKffTOSUkXp26rgdnC0PicnmnDak&index=37)
.substring();               Если вписать (5) - выводит строку с 5го символа, если (5, 10) - с 5го по 10й
.join();                    соединяет строки с учетом разделителя
.contains                   проверяет, содержит ли строка заданную последовательность символов и возвращает true или false
сompare();                  сравнивает две строки
getChars();                 возвращает группу символов
equalsIgnoreCase();         сравнивает строки без учета регистра
regionMatches();            сравнивает подстроки в строках
indexOf();                  находит индекс первого вхождения подстроки в строку
lastIndexOf();              находит индекс последнего вхождения подстроки в строку
startsWith();               определяет, начинается ли строка с подстроки
endsWith();                 определяет, заканчивается ли строка на определенную подстроку
replace();                  заменяет в строке одну подстроку на другую ("что заменить", "новое значение");
 ! replaceAll();
----- // String заносит строку в стиминг пул и она не меняется. Если задается новое значение - это новое заносится
туда, а старое так там и остается. Лучше работают StringBuffer и StringBuilder, они в случае изменения не создают
новое значение, а изменяют существующее. StringBuffer синхронизирован (потокобезопасен) и по этому скорость работы
хромает. StringBuilder такой же, но не синхронизирован, по этому работает гораздо быстрее.
.append();                  добавить к строке, в конец
.insert();                  добавить по индексу (3, "лгпрл")
.delete();                  удалить
.charAt();                  получить индекс / символ
.setCharAt();               изменить символ по индексу
.capacity();                показывает кол-во символов, для которых Выделена память
.ensureCapacity();          меняет макс. длины выделенной памяти для символов
.getChars();                получает символы в диапазоне (Начало, Конец, Имя_массива, 0) - там где 0 - с какой ячейки вставлять
.substring();               обрезка, (3) - с 3го индекса до конца, (3, 7) - с 3го до 7го.
.length();                  длина
.setLength();               изменение, если больше - добавятся пустые строки ' ', если меньше - урежутся
.replace();                 замена, (3, 7, "новое") - с какого, по какой, что поставить
String.format
%s                          текст
%d                          цифры
%f                          дробное
%b                          boolean
%c                          char
%t                          Date
%%                          %
%n                          перенос на след. строку


Math
.max(x, y);                 макс
.min(x, y);                 мин
.sqrt(x);                   Получить корень числа
.pow(x, 2);                 Возвести x в степень 2
.abs(x);                    Сделать цифру + положительной
.random();                  Выдаст рандом от 0 до 0.99999 и т.д.
.round();                   Округление к ближайшему целому
#1: SplittableRandom random = new SplittableRandom();       |   int numb2 = random.nextInt(1, 7);   // делают то
#2:         Random random = new Random();                   |   int numb3 = random.nextInt(7);      // же самое

StackTraceElement
.getClassName();        //
.getMethodName();
.getLineNumber();       // номер строки в файле
.getFileName();         // имя файла (в 1м файле может быть много классов)
.getModuleName();       // имя модуля
.getModuleVersion();    // версию модуля

*//**                                                    Ф И Ш К И
    Switch / case *//*
switch (ВыраженияДляВыбора) {    switch (SettedNumber) { // установленное число
    case (значение 1):           case 1:
        Код что делать;             System.out.println("Это 1я планета от Солнца");
        break;                      break;
    case (значение 2):           case 2:
        Код что делать;             System.out.println("Это 2я планета Меркурий");
        break;                      break;
    .                             и так далее
    .                                   s
    .                                   s
    default:                            s   // default не обязателен, тогда ничего выполнено не будет, если никакой из case не подошел
        КодПоУмолчанию;                 s
        break;                          s   // break тоже не обязателен -> !!Если его нет, после нахождения "case" программа выполнит то, что там и дальше без проверки других "case" будет выполнять их код, пока не встретит break или до окончания оператора switch;
} Логика - Если "ВыраженияДляВыбора" совпадает с "case", то выполняется код в нем *//**

    Дата    *//*
    О С Н О В Н О Е
Что есть - Data (устаревший, вместо него используют GregorianCalendar), SimpleDateFormat и
Calendar (GregorianCalendar). Редактировать время используя Calendar, а выводить = SimpleDateFormat
Нужно создать объект SimpleDateFormat и указать формат ("dd MM yyy"), после чего нужно само время, которое вывести
в таком формате. К примеру Calendar date = new GregorianCalendar(); <- если ничего не указивать будет иметь нынешнее
время и дату.

    S i m p l e D a t e F o r m a t
У SimpleDateFormat есть методы:
1. sdf.format(date.getTime());      // sdfСсылкаНаОбъект.format(ссылка_на_календарь);
2. sdf.parse(); {
String format = "09/02/1982 15:58:32";                      // Есть строка с временем
SimpleDateFormat sdf = new Sim..at("dd/MM/yyyy hh:mm:ss");  // Нужно написать в каком формате принимать
Date date = sdf.parse(format);                              // поместили в дату значение: обработанная строка в sdf
}                                   // осталось вывести date..
3. Конвертировать дату в календарь (97line)
Calendar calendar = Calendar.getInstance();
calendar.setTime(date);

    С Р А В Н Е Н И Е   Д В У Х   Д А Т  ! ! ! !
DateTimeFormatter formatter = DateTimeFormatter.patternOf("dd.MM.yyyy");    // написать формат строки

String str1 = "24.03.1997", str2 = "30.05.2000";        // пример
LocalDate date1 = LocalDate.parse(str1, formatter);     // указывается (дата, и_формат_даты)
localDate date2 = LocalDate.parse(str2, formatter);

Period period = Period.between(date2 , date1);          // вычеслит разницу, получить значения:
period.getMonths(); | period.getYears(); и т.д.

! Если находится во времени, к примеру Calendar cal = Calendar.getInstance();
SimpleDateFormat sdf = new SimpleDateFormat("dd.MM.yyyy");
DateTimeFormatter formatter = DateTimeFormatter.patternOf("dd.MM.yyyy")
LocalDate date1 = LocalDate.parse(sdf.format(cal.getTime()), formatter); - вот так для обоих

    Р А Б О Т А   С   К А Л Е Н Д А Р Е М
GregorianCalendar nameCalendar = new GregorianCalendar();       // можно так (2020, Calendar.MARCH, 10);
.set(Calendar.YEAR, 2010);
     Calendar.MONTH, 2);            // С нуля
     Calendar.DAY_OF_MONTH, 10);    // Можно написать -10 и оно вычтет 10 дней
     Calendar.HOUR_OF_DAY, 14);
     Calendar.MINUTE, 52);
     Calendar.SECOND, 30);
.add                                // Все варианты выше будут прибавлять данные значения или отнимать.
.roll();                            // меняет одно значение без изменений других
.get();                             //
.isLeapYear(год);                   // true - если високосный, false...
.areFieldsSet;                      // были ли установлены компоненты времени
.getTime(); / .setTime();           // Для преобразования из Date в Calendar (set) и обратно (get)
.Calendar.getInstance();            // не знаю что делает..
    М А Т Е Р И А Л Ы
https://www.codeflow.site/ru/article/java__java-date-and-calendar-examples
http://proglang.su/java/date-and-time *//**

     Узнать четные или не четные числа в вводимом числа (124, 235235)*//*
for (; n != 0; n/=10) {
    if (n % 2 == 0) even++;
    else odd++;}  *//**

     Регулярные выражения *//*
За регулярки отвечают 2 метода: Pattern, Matcher. Паттерну мы передаем <строку с выражением>, а второму - сам паттерн.
 1. Pattern это синглтон, т.е. создание объекта возможно только внутри самого класса. Что бы он создал и присвоил нам
объект - нужно объявить ссылку Pattern pattern и вызвать метод ('=') compile( куда передается строка ). К примеру:
String line = "A.+a";
Pattern patter = Pattern.compile(line, Pattern.CASE_INSENSITIVE);   // последний - сравнивает без учета регистра
В этом примере первое - строка с самим выражением, второе - режим сравнения шаблона с текстом.

Методы (пишутся pattern.METHOD();):
 - String .pattern()                    Возвращает строку с паттерном
 - boolean .matches(pattern, words)     Первое - паттерн (A.+a), второе - по чему сверять (строка, "Анна Егор Алекса")
 - int .flags()                         Вовзращает номер режима (шаблона)
 - String[] .split(words, 10)           Разбивает текст words на массив элеметров типа String. Вторым значением -
                                            определяет предельное кол-во совпадений, что нужно искать.
                                            больше 0 - столько и скать (к примеру если  3 - искать 3)
                                            меньше 0 - искать все
                                            равно 0 - искать все, пустые строки в конце массива отбрасываются

 2. Matcher - это "поисковик", движек. Что бы работать ему нужен шаблон по которому искать (паттерн) и где искать (строка).
За создание отвечает .matcher(), куда передаются строка, где искать (послед. символов), почти любые классы. Как работает:
Matcher matcher = patter.matcher(line);

Методы (matcher.find()):
 - boolean .find()                      Если находит - true, если нет - false
 - String .group()                      Дает строку того, что нашло
 - int .start()                         С какого индекса начинаются
 - int .end()                           На каком индексе заканчиваются
 - String .replaceFirst()               Заменить только первое совпадение на ("что-то еще");
 - String .replaceAll()                 Заменить все совпадения на ("что-то еще");

Пример:
String words = "Егор Алла Анна";
Pattern pattern = Pattern.compile("A.+?");

Matcher matcher = pattern.matcher(words);
while (matcher.find()) {
    int start = matcher.start();
    int end = matcher.end();
    System.out.printf("Совпадение: %s (начало с %d до %d)", words.substring(start, end), start, end-1");
}
System.out.println(matcher.replaceFirst("На-это"));     // Егор На-это Анна
System.out.println(matcher.replaceAll("На-это"));       // Егор На-это На-это
System.out.println(words);                              // Егор Алла Анна


Синтаксис - использования знаков <([{\^-=$!|]})?*+.> вместе с символами (буквами):
    1. Метасимволы для поиска совпадений границ строк или текста
        ^	    начало строки
        $	    конец строки
        \\b	    граница слова
        \\B	    не граница слова
        \\A	    начало ввода
        \\G	    конец предыдущего совпадения
        \\Z	    конец ввода
        \\z	    конец ввода
    2. Метасимволы для поиска символьных классов
        \\d	    цифровой символ [0-9]
        \\D	    нецифровой символ [a-zA-Z]
        \\s	    символ пробела
        \\S	    непробельный символ
        \\w	    буквенно-цифровой символ или знак подчёркивания
        \\W	    любой символ, кроме буквенного, цифрового или знака подчёркивания
        .	    любой символ
    3. Метасимволы для поиска символов редактирования текста
        \t	    символ табуляции
        \n	    символ новой строки
        \r	    символ возврата каретки
        \f	    переход на новую страницу
        \u0085	символ следующей строки
        \u2028	символ разделения строк
        \u2029	символ разделения абзацев
    4. Метасимволы для группировки символов
        [абв]	любой из перечисленных (а,б, или в)
        [^абв]	любой, кроме перечисленных (не а,б, в)
        [a-zA-Z]	    слияние диапазонов (латинские символы от a до z без учета регистра )
        [a-d[m-p]]	    объединение символов (от a до d и от m до p)
        [a-z&&[def]]	пересечение символов (символы d,e,f)
        [a-z&&[^bc]]	вычитание символов (символы a, d-z)
    5. Метасимволы для обозначения количества символов – квантификаторы. Квантификатор всегда следует после символа
    или группы символов.
        ?	    один или отсутствует
        *	    ноль или более раз
        +	    один или более раз
        {n}	    n раз
        {n,}	n раз и более
        {n,m}	не менее n раз и не более m раз
    6. Ост.
        \Q...\E     Java воспринимает как "дословно", т.е. не нужно слешить (1+2=3 -> 1\\+2=3 -> \\Q1+2=3\E)
// Регулярные выражения задаются с использованем строкового литерала \, на который в Java есть своим правила. При
написании этого знака java ожидает какой-то спец-символ, он интрпритируется как символ управляющей последовательности.
Он предупреждает, что символ за ним - специальный и его нужно по другому итерпритировать. По этому тут это знак нужно
дублировать - \\ примеры (String l):
1. l = "\\s"                пробел
2. l = "\u2028"             Спец. знак
3. l = "How\\?"             How?
4. l = "\\"Welcome\\!\\""   "Welcome!" (?)
5. l = "\n"                 перево на новую строку
Есть 3 режима, их понимать сложно, но они весьма крутые, это A.+a (+), A.++a (++) и A.+?a (+?). Как работают
    A.+a    это называется жадный режим. Он ищет первую букву А, потом ищет ЛЮБОУЮ букву 1+ раз.. т.е. ищет
                пока строка не закончится.. ну ведь + значит от 1 до бексонечности) Так что строка заканчивается...
                и идет след. символ - 'a'. Он с конца ищет его, и отбрасывает заднюю часть тех букв, что не 'a'
                Egor Alla Aleksandr -> "Alla Aleksa"
    А.++а   это сверхжадный режим... он ищет А, потом до конца строки любую букву.. и все. После дохождения до
                конца он пытается выполнить след. условие -> а, но там ничего нет. Он ничего и не покажет. Получше
                примеров не нашел, сложно бе бе бе.
    А.+?а   это ленивый квантификатор. Как он работает - он находит букву А, после чего ищет любую букву.. Когда он
                находит любую букву - он начинает искать 'a'.
                Egor Alla Aleksandr -> "Alla" и "Aleksa"
                                 A -> нашел любую букву 'l' -> ищет 'a'

Проверки:
что-то(?=Y)         - найди (что-то), при условии, что за ним Y. Если написать несколько (?=Y)(?=C), то за (что-то) должно быть и Y и С
                        \\d+(?=€) -> Ищет число, за котороым стоит €
что-то(?!Y)         - найди (что-то), при условии, что за ним НЕТ Y
                        \\d+(?!€) - Ищет число, за которым нет €
(?<=Y)(что-то)      - найди (что-то), но перед ним должно быть Y
                        (?<=[?&]).+ - Ищет все буквы после знаков ? и &
(?<!Y)(что-то)      - найди (что-то), но перед ним НЕ должно быть Y
                        (?<![a-zA-Z\\s])\\b\\d+ - Ищет все цифры, перед которыми не идут буквы и пробел (.241 - ок)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *//**
     Тема    *//*

 *//**       ------------      ------------    П Р О Ч Е Е       ------------      ------------      ------------                                                                         *//*
main ->  System.out.println(line("Рука_", 1));
private static String line(String s, int count){                // Многократно УСКОРЯЕТ работу кода
        StringBuffer buf = new StringBuffer();                  // создали объект нашего буфера
        for (int i = 0; i < count; i++) {
            buf.append(s);                                      // использовали команду, которая добавляет
        }                                                          строку s к концу строки, имеющейся в буфере
        return buf.toString();
    }

for (int i = name.length - 1; i > 0; i--) {                     // Цикл для, меняет местами содержимое ячеек наоборт
    for (int j = 0; j < i; j++) {
        if (name[j] > name[j + 1]) {
            proc = name[j];                                     // Если числа, то int proc =...
            name[j] = name[j + 1];                              // Если текст, то String proc = ...
            name[j + 1] = proc;
        }
    }
}

public static String toString() {                               // вид для изменения toString
    return ;
}
*//**       ------------      ------------    М А С С И В    v.s.  A r r a y L i s t       ------------      ------------      ------------                                                                         *//*
            Массив:                                                     ArrayList
Использовать, когда мы знаем точный объем массива.          Использовать, если мы не знаем какая длина нам нужна.
                                                            Это как резиновый массив

                                        Объявления (начала там public, static если надо):

Тип_Данных[] Имя_переменной = new Тип_Данных [сколько];     ArrayList <Тип_Данных> Имя_переменной = new ArrayList<>;
String[] textArray = new String[10];                        ArrayList <String> textArray = new ArrayList<>;

В "сколько" должно быть только число типа int.              Объем не указываем, он резиновый. Вместо <String> можно быть
                                                                какой-то класс, типа <Cat> и т.д. Для простых переменных типа
                                                                int, double  нужно использовать класс-оболочку <Integer> / <Double>

                                            Как обращаться:
Длина:          textArray.length                            textArray.size();
Как положить:   textArray[0] = "Положить строку";           textArray.add("Положить строку");
                                                            textArray.add(0, "в начало добавить"); = Добавит в 0 новое значение, все остальные сдвинутся вниз
Как взять:      textArray[0] (так же)                       textArray.get(0);
Изменить:       textArray[0] = "Новая строка";              textArray.set(0, "Новая фраза");
   (т.е. тут менять так же, как и ложить,                   textArray.remove(1); или
    т.к. нельзя добавлять новый, как в ArrayList.           textArray.remove("Положить строку"); = удалять можно по строке (данной) и по индексу
Содержит:       ----                                        textArray.indexOf("Положить строку"); (еще .contains(""); - узнать под каким индексом эта строка.. будет 1 (т.е. под 0 мы поставили "в начало добавить"). Выдаст -1, если такого нет.
Очистить:       textArray = null                            textArray.clear();
Отсортировать:  Arrays.sort(textArray);                     Collections.sort(textArray); = sort - от меньшего к большему (от а до я). reverse - обратно.
Скопировать:    Arrays.copyOf(tA, tA.length);
    copyOf(tA, 4) | если написать copyOfRange(tA, 2,6)
    то будет скпировано -> (2, 3, 4, 5)
Вывести:        Arrays.toString(textArray);                 System.out.println(list);
Сравнить:       Arrays.equals(tA_1, tA_2);
Длина строки:   textArray[0].length();                      tA1.retainAll(tA2); - А в tA1 оставит лишь то, что есть в tA2, все остальное удалит. В tA2 удалит все строки, что повторяются в tA1. Пример: если в 1 есть слова "Рыба" и "Машина", а вот втором есть слова "Ноут" и "Рыба", тогда в 1м останется только "Рыба", а во втором - "Ноут".
Для копирования Двумерных массивов используется то же,      Collections.addAll(textArray, "dwed", "dwedew"); || Collections.addAll(textArray, new Cat("Po6ept"), new Cat ("Mayc9"));
что и для обычнах. А для других дел -                           Так же в ArrayList могут быть 2 одиновых значения, т.е. повторяться. И если нам нужно узнать не
Arrays.deepEqual(tA1, tA2); и Arrays.deepToString(tA);          индекс, а к примеру сколько раз фраза была введена в ArrayList, то нужно будет перебирать весь массив.







*//**       ------------      ------------      H a s h S e t   (n - name)     ------------      ------------      ------------      ------------                                                                         *//*
У HashSet'а есть свои методы. Так же Set, List & Queue могут использовать колеции. Так что помимо немногих своих
можно использовать Collections. Свои:
n.add("что-то");
n.remove("какую строку");           - выдаст true если такой элемент был
n.contains("поиск_строки");         - выдаст true / false
n.size();
n.clear();

Что бы вывести
for (String g : n) System.out.println(g); - присвой g каждый элемент по 1му, что есть в Сете.
    Длинная запись:
        Iterator<String> iterName = n.iterator();
        while (iterName.hasNext()) {
            String g = iterName.next();
            System.out.println(g);
        }
*//**       ------------      ------------      H a s h M a p   (n - name)     ------------      ------------      ------------      ------------                                                                         *//*
Методы:
n.put (key, value);                     - добавить. Если такой key уже есть, то старое value заменится на новое
n.get (key);                            - узнать value введя (key)
n.containsKey();                        - Проверяет наличие ключа (первое значение). Выдаст true/false
n.containsValue();                      - значения (второе значение). Выдаст true/false
n.remove(key);                          -
n.clear();
n.size();                               - Возвращает кол-во пар
n.isEmpty();                            - пустой ли
n.keySet();                             - Получить множество ключей
n.values();                             - Получить множество значений
n.entrySet();                           - Получить множество всех пар

Что бы вывести
Самый простой - получить key и по ниму вывести value:
    for (String gKey : n.keySet()) {
        String gValue = n.get(gKey);
        System.out.println(gKey + " - " + gValue);
    }

"Другой":
    for (Map.Entry<String, String> pair : n.entrySet()) {
        String gKey = pair.getKey();
        String gValue = pair.getValue();
        System.out.println(gKey + " - " + gValue);
    }

!! Удалять нужно или с помощью копии мапы или итератора, только они смогут правильно удалить без ошибок. Итератор:
    Iterator<Map.Entry<String, String>> iterName = map.entrySet().iterator();
    while (iterName.hasNext()) {
        Map.Entry<String, String> pair = iterName.next();
        String key = pair.getKey();
        String value = pair.getValue();
        if (pair.getValue().equals("рука")) {
            iterName.remove();
        }
    }
Так же это все можно заменить - map.entrySet().removeIf(pair -> pair.getValue().equals("рука"));   лямбды они такие


*//**       ------------      ------------      Ч Т Е Н И Е   И   З А П И С Ь      ------------      ------------      ------------      ------------                                                                         *//*
Для чтения файла и записи используются 4 класса - байтовые (InputStream OutputStream) и символьные (Reader & Writer).
    Данные записываются (передаются) в байтах, по этому, что бы было удобней - нужно потом эти данные обворачивать
    другими классами. Есть еще класс File, однако он работает непосредственно с файлами (получить информацию о файле:
    права доступа, время и дата создания), для работы с данными файла нужно использовать поток (Stream).
InputStream - запись чего-то в программу. Что бы записать нужно считать данные откуда-то, для этого используется
    методо .read()
OutputStream - выгрузка из программы (запись в файл). Используется метод .write();
Сами по себе они абстрактные, по этому новый объект нужно создавать FileInputStream или FileOutputStream
OutputStream name = new FileOutputStream("/путь/к/файлу.txt", true);       // true - добавить в конец, false - перезаписать

ОСНОВНОЕ:
    Чтение:
        1. Нужно создать InputStream - начать считывать байты.
        2. Этот "поток" обернуть символьным классом - InputStreamReader
        3. Если нужно - считыть построчно через BufferReader
        BufferedReader rd = new BufferedReader (new InputStreamReader(new FIleInputStream("/.../ways.txt")));
    Проще:
        BufferedReader rd = new BufferedReader (new FileReader("/.../ways.txt"));
    Запись.. тоже самое, что и чтение
        BufferedWriter bw = new BufferedWriter (new FileWriter("/.../path.txt"));

 ------ ------ ------ ------ ------ ------ Байтовые ------ ------
 Чтение:
 ! - BufferedInputStream
 - ByteArrayInputStream
 - DataInputStream
 ! - FileInputStream - для чтения файла в байтах
 - ObjectInputStream
 - PipedInputStream
 - FilterInputStream
 Запись:
Первые два используется для получения данных и их дальнейшего преобразования в более удобным форма. Для это есть
достаточно много классов... сначала рассмотрим менее удобный - байтовые:
 ! - BufferedOutputStream - Буферизированный выходной поток (повышения производительности)
 - ByteArrayOutputStream - Создает буфер в памяти. Все данные, посылаемые в этот поток, размещаются в созданном буфере (использует байтовый массив в выходном потоке. Метод close() можно не вызывать)
 - DataOutputStream - Выходной поток, включающий методы для записи стандартных типов данных Java
 ! - FileOutputStream - Отправка данных в файл на диске. Реализация класса OutputStream
 - ObjectOutputStream - Выходной поток для объектов
 - PipedOutputStream - Реализует понятие выходного канала.
 - FilterOutputStream - Абстрактный класс, предоставляющий интерфейс для классов-надстроек, которые добавляют к существующим потокам полезные свойства.
Их методы:
! int .available() - говорит, сколько байтов осталось в файле.. если пусто выбрасывает -1
! int .close() - закрывает выходной поток. Следующие попытки записи передадут исключение IOException
! abstract void .write (int oneByte) - записывает единственный байт в выходной поток
void .flush() - финализирует выходное состояние, очищая все буферы вывода
void .write (byte[] buffer) - записывает полный массив байтов в выходной поток
void .write (byte[] buffer, int offset, int count) - записывает диапазон из count байт из массива, начиная с смещения offset

------ ------ ------ ------ ------ ------ Символьные: ------ ------
 Символьные потоки имеют два основных абстрактных класса Reader и Writer, управляющие потоками символов Unicode.
            1. Reader:  -- Чтение из файла
! - BufferedReader - Буферизированный входной символьный поток (увеличивает производительность за счёт буферизации ввода)
 - CharArrayReader - Входной поток, который читает из символьного массива
! - FileReader - Входной поток (можно использовать для чтения содержимого файла)
 - FilterReader - Фильтрующий читатель
! - InputStreamReader - Входной поток, транслирующий байты в символы
 - LineNumberReader - Входной поток, подсчитывающий строки
 - PipedReader - Входной канал
 - PushbackReader - Входной поток, позволяющий возвращать символы обратно в поток
 - StringReader - Входной поток, читающий из строки
Их методы:
abstract void .close() - закрывает входной поток. Последующие попытки чтения передадут исключение IOException
! int .read() - возвращает целочисленное представление следующего доступного символа вызывающего входного потока. При достижении конца файла возвращает значение -1. Есть и другие перегруженные версии метода
! void .mark(int readLimit) - помещает метку в текущую позицию во входном потоке
! boolean .ready() - возвращает значение true, если следующий запрос не будет ожидать.
boolean .markSupported() - возвращает true, если поток поддерживает методы mark() и reset()
void .reset() - сбрасывает указатель ввода в ранее установленную позицию метки
logn .skip(long charCount) - пропускает указанное число символов ввода, возвращая количество действительно пропущенных символов
            2. Writer: -- Запись в файл
 - BufferedWriter - Буферизированный выходной символьный поток (можно повысить производительность за счёт снижения количества операций физической записи в выходное устройство)
 - CharArrayWriter - Выходной поток, который пишет в символьный массив (использует массив для выходного потока)
 - FileWriter - Выходной поток, пишущий в файл (Есть конструкторы, которые позволяют добавить вывод в конец файла)
 - FilterWriter - Фильтрующий писатель
 - OutputStreamWriter - Выходной поток, транслирующий байты в символы
 - PipedWriter - Выходной канал
 - PrintWriter - Выходной поток, включающий методы print() и println()
 - StringWriter - Выходной поток, пишущий в строку
Их методы:
Writer .append(char c) - добавляет символ в конец вызывающего выходного потока. Возвращает ссылку на вызывающий поток
Writer .append(CharSequence csq) - добавляет символы в конец вызывающего выходного потока. Возвращает ссылку на вызывающий поток
Writer .append(CharSequence csq, int start, int end) - добавляет диапазон символов в конец вызывающего выходного потока. Возвращает ссылку на вызывающий поток
abstract void .close() - закрывает вызывающий поток
abstract void f.lush() - финализирует выходное состояние так, что все буферы очищаются
void .write(int oneChar) - записывает единственный символ в вызывающий выходной поток. Есть и другие перегруженные версии метода

PrintStream / PrintWriter - отвечает за вывод потока на консоль.
PrintStream - Наш любимый клас... System.out.println - в Классе System есть постоянная переменная out типа PrintStream
    (т.е. это объект).. и каждый раз мы вызываем:
    System (имя класса).out (ссылка на объект типа PrintStream). println(метод в классе PrintStream)

*//**   -----------      ------------      ------------      ------------      ------------      ------------      ------------      ------------                                                                        *//*
ArithmeticException - арифметическая ошибка, например, деление на нуль
ArrayIndexOutOfBoundsException - выход индекса за границу массива
ArrayStoreException - присваивание элементу массива объекта несовместимого типа
ClassCastException - неверное приведение
EnumConstantNotPresentException - попытка использования неопределённого значения перечисления
IllegalArgumentException - неверный аргумент при вызове метода
IllegalMonitorStateException - неверная операция мониторинга
IllegalStateException - некорректное состояние приложения
IllegalThreadStateException - запрашиваемая операция несовместима с текущим потоком
IndexOutofBoundsException - тип индекса вышел за допустимые пределы
NegativeArraySizeException - создан массив отрицательного размера
NullPointerException - неверное использование пустой ссылки
NumberFormatException - неверное преобразование строки в числовой формат
SecurityException - попытка нарушения безопасности
StringIndexOutOfBounds - попытка использования индекса за пределами строки
TypeNotPresentException - тип не найден
UnsupportedOperationException - обнаружена неподдерживаемая операция


Список проверяемых системных исключений, которые можно включать в список throws.
ClassNotFoundException - класс не найден
CloneNotSupportedException - попытка клонировать объект, который не реализует интерфейс Cloneable
IllegalAccessException - запрещен доступ к классу
InstantiationException - попытка создать объект абстрактного класса или интерфейса
InterruptedException - поток прерван другим потоком
NoSuchFieldException - запрашиваемое поле не существует
NoSuchMethodException - запрашиваемый метод не существует
ReflectiveOperationException - исключение, связанное с рефлексией






















*/
