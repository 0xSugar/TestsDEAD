package com.company;
public class NotesSQL {}

/**
 * Какое-то вступление.
 * @author skul
 */

/*
* Для работы с базой данных нужно пару программ. Минимум это клиент-сервер:
* Клиент - программа, которая посылает запрос в базу данных
* Сервер - программа (PostgreSQL), которая обрабатывает запрос и возвращает результат в виде таблицы
*
* Это минимум для работы. Сервером является Postgre, тогда как клиентом в моем случае - DataGrid Так же можно
* использовать дополнительные программы, к примеру:
* -> pg_ctl (pg_ctlcluster) - используется для запуска, перезапуска и прочей работы сервера
*
*
*
*
*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *//**
    Создание таблицы    *//*
CREATE TABLE table_name (
        id int,
        first_name text,
        last_name text,
        isMan boolean
        birthday DATE
    )

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *//**
    Создание запроса    *//*
SELECT * FROM mydb WHERE age < 18 ORDER BY first_name, last_name LIMIT 5;
SELECT          команда, выбрать
*               из всех колонок (или перечислить через запятую нужные колонки
WHERE           команда, по какому условию (OR, AND, IN, BETWEEN)
        AND & OR, дальше идет название колонки и условие, = < > !=.  OR можно заменить на ...
        IN - перечисляем вирианты, что бы не писать (country = 'UA' AND country = 'US')
            WHERE country IN ('ЮА', 'ЮС')..
        BETWEEN - WHERE price BETWEEN 10000 AND 20000 (вместе price > 10000 AND price < 20000) // не знаю на счет, это больше или равно или строго больше...
        Можно комбинировать: SELECT * FROM sqlData WHERE country IN ('UA', 'US') AND age > 18.
ORDER BY        сортировка (для строк - алфавитный порядок)
        first_name - сортировка только по имени в алф. порядке
        first_name, last_name - сортировка по имени сперва, и потом по фамилии (все логично.. если одинаковые имена и разные фамилии - фамилии так же будут отсортированы)
        birthday DESC - сортировка по дате, но с DESC - в обратном порядке
        first_name, birthday SECT - сначала алф порядок имени, потом наоборот дату с большего к меньшему
LIMIT               ограничего на вывод,
        5;          вывод только 5 результатов
        3, 5;       первое число - сколько нужно ПРОПУСТИТЬ, второе - сколько получить. Мы ограничили вывод 5ю
                    товарами и дописали, что первые 3 - пропустить. Т.е. при лимите так же можно пропускать самые
                    верхние варианты и выводить те, что после них... если они есть.. если будет меньше -
                    выдаст 1 или 2.. меньше, но первые 5 - пропустит

Удаление:
    Синтаксис такой же, как и SELECT.
    delete from list where country = 'ua' and (age < 18 or age > 30);
    Очистить лист - delete from list; или truncate table list;
    P.S.: ВАЖНО! - сначала через SELECT выбираем данные, смотрим - если все ок, то меняем SELECT на DELETE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *//**
    Добавление данных в таблицу    *//*
Синтаксис -> INSERT INTO название_таблицы (столбика_1, столбик_2, и_т_д) VALUES ('значение 1', 30, '<- число без скобок');
Пример:
    INSERT INTO users (first_name, last_name, email, salary) VALUES ('Женько', 'Петков', 'j@gmail.com', 1);
Добавить можно сразу несколько "полей":
Синтаксис -> INSERT INTO название_таблицы (столбик_1, столбик_2)
            VALUES ('значение 1.1', 'значение 1.2'),
                   ('значение 2.1', 'значение 2.2');
Пример:
    INSERT INTO users (name, age) VALUES ('Женько', 18), ('Петько', 20), ('Рудько', 17);

Так же это можно записать другим сопособом, через SET:
Синтаксис -> INSERT INTO название_таблицы SET столбик_1 = someth, столбик_2 = someth;
Пример:
    INSERT INTO users SET first_name = 'Женько', last_name = 'Петков', email = j@gmail.com, salary = 1;
Как логично понятно -> можно создать поле, после чего этой командой присвоить значения.. или изменять.. это мне надо.



P.S.: дата записывается в виде 'гггг-ММ-дд' ('2020-24-04')                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *//**

    Прочее    *//*
Если идет перечисление, к примеру WHERE id = 3, 4, то это нужно записывать в скобках - WHERE id = (3, 4)
UPDATE - изменить данные в строке, DELETE - полность удалить строку

ENUM - что-то одно, в примере status enum ('new', 'confirmed', 'cancelled'); - теперь при добавлении
    сюда будут доступны только одно из 3х значений, иначе выдаст ошибку.
SET - можнт быть несколько, пример (удобства) facilities SET('wifi', 'ac', 'view', 'tv'); - сюда можно дабвить
    как одно, так и пустую строку '', так и несколько значений 'wifi,ac' (без пробелов). После чего можно будет
    запросто найти по запросу SELECT * FROM table WHERE FIND_IN_SET ('wifi', facilities); - покажет все варианты,
    где есть wifi. Если нужно несколько - WHERE FIND_IN_SET ('wifi', facilities) AND FIND_IN_SET ('tv', facilities);
    Покажет те варианты, где есть и wifi и tv, весьма удобно.

Обновление данных
После WHERE синтаксис такой же, как и в SELECT.. можно добавить ORDER BY & LIMIT;
Синтакс -> UPDATE название_таблицы SET столбик = 'новое_значение' WHERE столбик = 'старое значение';
Пример:
    UPDATE users SET name = 'Женько' WHERE name = 'жЕнько'; (лучше изменять по id, WHERE id = 15;)
Пример 2:
    UPDATE products SET price = price * 0.99 ORDER BY price DESC LIMIT 1; <- изменить цену в товаре, какой? - отсортируй по уменьшению цены и возьми первый.
    т.е. означает - у товара с самой большей ценой изменить цену на цена * 0.99.

UNSIGNED - пришется к INT при создани колонки... убирает минусовую часть и максимум становится в 2 раза больше
есть (TINYINT - byte, SMALLINT - short, MEDIUMINT -8.38кк +8.38кк, INT - int & BIGINT - long)
Дата сейчас - CURRENT_TIMESTAMP (можно в дефолт всунуть)
PRIMARY KEY(если их несколько, то дописать отдель primary key (id, id_2) - уникальным только оба значения, к 1 1, значения 2 1 и 1 2 не будут уникальны, только 1 1
UNIQUE KEY (какой-то параметр, еще один) в конце.. если несколько, то работает как выше.
    UNIQUE KEY (pad, pad2), UNIQUE KEY (som); - уникальность отдельно у som и у связки pad-pad2
    UNIQUE KEY mykey (pad, pad2) - можно создать ключ mykey по каким-то уникальным полям

AUTO_INCREMENT
CREATE INDEX название ON лист(столбец) = CREATE INDEX player_index ON mons(user_id)
    команда создаст индекс.. все одинаковые значения в user_id перекинутся, как бы в отдельный файл, и когда
    при поиске нужно будет искать в user_id = 240, он не будет просматривать все все записи в таблице, а сразу
    выберет этот список, где у каждого поля значение = 240 и покажет его. Многократно ++ к производительности.
    База должна обработать все записи и сформировать индексы.. это занимает на 1кк записей ~ 5с. (в теории.. при этом поиск по этому значению ускоряется в раз 6)
    ! Можно добавлять индексы и во время создания таблицы:
        Для этого в конце создания таблицы нужно указать INDEX player_index (user_id), где
        INDEX название_индекса (по_какому_полю)
    SHOW INDEXES FROM table_name
    DROP INDEX some_index_name ON (table_name)
    Так же можно создать индекс по несколько колонкам index (col1, col2)
    Для уникального ставится unique перед индексом.. уникальные служат в основм для создания нескольких значений
        к примеру номер серии и пасспорт create unique index sepass on table(series, passport);... если не
        использовать несколько значений, то это ТОЖЕ САМОЕ, что и unique key.. удалять unique key так же, как и
        индекс - drop index NAME on table; <- даже если NAME создан как unique key, а не index.. просто тоже самое.
Создание колонки
    ALTER TABLE table_name ADD COLUMN col_name int default 1...параметры

*//**       ------------      ------------      D a t a G r i d (код)      ------------      ------------      ------------      ------------                                                                         *//*
Можно все делать как через графический интерфейс, так и через код. К примеру, что бы добавить в список heroes
    какое-то поле, можно перейти в таблицу, нажать плюсик и заполнить все полня, после чего нажать Submit и готово.
Но IDL переделывает это все в строку. И если строк много - можно это все сделать через sublime, скопировав с
    консоли уже сгенерированный код и поставив свои значения. Вот что мы получили (разделил на 2 строки):
        INSERT INTO public.heroes (id, nickname, firstname, lastname, email, date)
        VALUES (3, 'someone', 'some', 'one', 'someone@gmail.com', '2020-04-24');
    Осталось изменить значение на null и скопировать сколько надо раз, и через sublime заменить все поля по очереди.

Cmd + Shift + A -> Transpose            Изменить отображение колонок


*//**       ------------      ------------      Т О Ч К А   В Х О Д А      ------------      ------------      ------------      ------------                                                                         *//*

*//**       ------------      ------------      Т О Ч К А   В Х О Д А      ------------      ------------      ------------      ------------                                                                         *//*

*//**       ------------      ------------      Т О Ч К А   В Х О Д А      ------------      ------------      ------------      ------------                                                                         *//*

*//**       ------------      ------------      Т О Ч К А   В Х О Д А      ------------      ------------      ------------      ------------                                                                         *//*

*//**       ------------      ------------      P o s t g r e s S Q L      ------------      ------------      ------------      ------------                                                                         *//*
Консольно - psql для входа в постгрес. Очень важно после каждой команды её закрывать ';'.
CREATE DATABASE my_db;              создает новую базу my_db
\list                               покажет лист с базами
\connect my_db                      подключится к базе, \connect postgres - обратно
DROP DATABASE my_db;                удалить базу данных

*//**       ------------      ------------     --------      --------      ------------      ------------      ------------      ------------
*/
